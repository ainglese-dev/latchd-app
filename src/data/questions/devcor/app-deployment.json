[
  {
    "id": "devcor-deploy-001",
    "question": "What is the difference between a Docker image and a Docker container?",
    "options": ["Images are running instances; containers are static templates", "Images are static templates; containers are running instances", "Images and containers are the same thing", "Images are for development; containers are for production"],
    "correct": 1,
    "explanation": "Docker images are read-only templates used to create containers. Containers are running instances of images. You build images, then run them as containers."
  },
  {
    "id": "devcor-deploy-002",
    "question": "Which Dockerfile instruction sets the base image for your container?",
    "options": ["BASE", "FROM", "IMAGE", "PARENT"],
    "correct": 1,
    "explanation": "FROM specifies the base image (e.g., FROM python:3.9). It's typically the first instruction in a Dockerfile. BASE, IMAGE, and PARENT are not valid Dockerfile instructions."
  },
  {
    "id": "devcor-deploy-003",
    "question": "How do Docker image layers improve build efficiency?",
    "options": ["Layers compress images to save disk space", "Layers are cached and reused if unchanged, speeding up builds", "Layers encrypt sensitive data in images", "Layers enable multi-architecture support"],
    "correct": 1,
    "explanation": "Docker caches each layer. If a layer hasn't changed, Docker reuses the cached version instead of rebuilding it, significantly speeding up builds."
  },
  {
    "id": "devcor-deploy-004",
    "question": "Which docker run flag maps a host port to a container port?",
    "options": ["-v or --volume", "-p or --publish", "-e or --env", "-n or --name"],
    "correct": 1,
    "explanation": "-p or --publish maps ports (e.g., -p 8080:80 maps host port 8080 to container port 80). -v is for volumes, -e for environment variables, -n for naming containers."
  },
  {
    "id": "devcor-deploy-005",
    "question": "What is the purpose of Docker volumes?",
    "options": ["To encrypt container data", "To persist data beyond container lifecycle", "To share CPU resources between containers", "To configure container networking"],
    "correct": 1,
    "explanation": "Volumes persist data outside the container's filesystem, surviving container deletion. They're used for databases, logs, and any data that needs to persist."
  },
  {
    "id": "devcor-deploy-006",
    "question": "Which Docker network mode allows a container to use the host's network stack directly?",
    "options": ["bridge", "host", "none", "overlay"],
    "correct": 1,
    "explanation": "Host mode (--network host) makes the container use the host's network directly without isolation. Bridge is the default isolated network, none disables networking."
  },
  {
    "id": "devcor-deploy-007",
    "question": "In Kubernetes, what is a Pod?",
    "options": ["A single container running in the cluster", "The smallest deployable unit that can contain one or more containers", "A Kubernetes worker node", "A storage volume for persistent data"],
    "correct": 1,
    "explanation": "A Pod is the smallest Kubernetes unit and can contain one or more tightly coupled containers that share network and storage. Containers within a Pod share localhost."
  },
  {
    "id": "devcor-deploy-008",
    "question": "What does a Kubernetes Deployment's replica count control?",
    "options": ["The number of nodes in the cluster", "The number of identical Pods to run", "The number of containers per Pod", "The number of storage volumes to create"],
    "correct": 1,
    "explanation": "The replica count specifies how many identical Pods should run. Kubernetes maintains this count, recreating Pods if they fail to ensure desired state."
  },
  {
    "id": "devcor-deploy-009",
    "question": "Which Kubernetes Service type exposes a service externally using a cloud provider's load balancer?",
    "options": ["ClusterIP", "NodePort", "LoadBalancer", "ExternalName"],
    "correct": 2,
    "explanation": "LoadBalancer creates an external load balancer (on cloud providers) to expose the service. ClusterIP is internal-only, NodePort exposes on node IPs."
  },
  {
    "id": "devcor-deploy-010",
    "question": "What is the difference between a ConfigMap and a Secret in Kubernetes?",
    "options": ["ConfigMaps store configuration; Secrets store sensitive data (base64-encoded)", "ConfigMaps are encrypted; Secrets are plain text", "ConfigMaps are for production; Secrets are for development", "There is no difference — they're interchangeable"],
    "correct": 0,
    "explanation": "ConfigMaps store non-sensitive configuration data, while Secrets store sensitive data like passwords and tokens (base64-encoded, though not encrypted by default)."
  },
  {
    "id": "devcor-deploy-011",
    "question": "In a docker-compose.yml file, what does the 'depends_on' key specify?",
    "options": ["The order in which containers share volumes", "The startup dependency order between services", "The network priority of each container", "The CPU allocation order for services"],
    "correct": 1,
    "explanation": "The 'depends_on' key in docker-compose.yml defines service startup order. If service B depends_on service A, Docker Compose starts A before B. Note that depends_on does not wait for a service to be 'ready,' only for it to be started."
  },
  {
    "id": "devcor-deploy-012",
    "question": "What is the primary benefit of a multi-stage Docker build?",
    "options": ["It allows running multiple containers from one Dockerfile", "It reduces the final image size by discarding build-time dependencies", "It enables parallel execution of application processes", "It automatically scales the number of container replicas"],
    "correct": 1,
    "explanation": "Multi-stage builds use multiple FROM statements in a single Dockerfile. Build tools, compilers, and intermediate artifacts are left behind in earlier stages, and only the final runtime artifacts are copied into the last stage, producing a much smaller production image."
  },
  {
    "id": "devcor-deploy-013",
    "question": "What is the purpose of Kubernetes namespaces?",
    "options": ["To isolate container processes at the kernel level", "To provide logical separation of resources within a cluster", "To define network subnets for Pod communication", "To encrypt secrets stored in etcd"],
    "correct": 1,
    "explanation": "Kubernetes namespaces provide logical isolation within a cluster. They allow teams to organize resources, apply resource quotas, and set RBAC policies independently. They do not provide network or kernel-level isolation by default."
  },
  {
    "id": "devcor-deploy-014",
    "question": "How does a Kubernetes readiness probe differ from a liveness probe?",
    "options": ["A readiness probe restarts the container on failure; a liveness probe does not", "A liveness probe removes the Pod from Service endpoints; a readiness probe restarts it", "A readiness probe controls whether traffic is sent to the Pod; a liveness probe controls whether the container is restarted", "There is no functional difference; they use different syntax for the same check"],
    "correct": 2,
    "explanation": "A readiness probe determines if a Pod is ready to receive traffic — failing it removes the Pod from Service endpoints. A liveness probe determines if a container is still running — failing it causes the kubelet to restart the container. They serve complementary but distinct purposes."
  },
  {
    "id": "devcor-deploy-015",
    "question": "What Kubernetes resource manages external HTTP/HTTPS access to services and provides host-based or path-based routing?",
    "options": ["LoadBalancer Service", "NodePort Service", "Ingress", "Gateway API Route"],
    "correct": 2,
    "explanation": "An Ingress resource defines rules for routing external HTTP/HTTPS traffic to internal Services based on hostnames and URL paths. An Ingress Controller (such as NGINX or Traefik) implements these rules. LoadBalancer and NodePort Services expose traffic but lack built-in host/path routing."
  },
  {
    "id": "devcor-deploy-016",
    "question": "Which of the following is a common public container image registry that Docker pulls from by default when no registry hostname is specified?",
    "options": ["GitHub Container Registry (ghcr.io)", "Amazon Elastic Container Registry (ECR)", "Docker Hub (docker.io)", "Google Artifact Registry"],
    "correct": 2,
    "explanation": "When you run 'docker pull nginx' without specifying a registry, Docker defaults to Docker Hub (docker.io). Other registries like ghcr.io, ECR, and Google Artifact Registry require explicit hostnames in the image reference."
  },
  {
    "id": "devcor-deploy-017",
    "question": "A team uses Helm to manage Kubernetes deployments. They need to deploy the same application to staging and production with different replica counts and resource limits. Which Helm feature allows them to override default configuration without modifying the chart templates?",
    "options": ["Helm hooks with pre-install jobs", "A custom values.yaml file passed with 'helm install -f'", "Helm chart dependencies in Chart.yaml", "Kubernetes kustomize overlays embedded in the chart"],
    "correct": 1,
    "explanation": "Helm charts use a values.yaml file for default configuration. Users can supply a custom values file with 'helm install -f custom-values.yaml' or use '--set' flags to override specific values. This allows the same chart templates to produce different manifests for different environments without modifying the templates themselves."
  }
]
