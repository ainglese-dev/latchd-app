[
  {
    "id": "devasc-cicd-001",
    "question": "What does CI stand for in CI/CD?",
    "options": ["Code Integration", "Continuous Integration", "Complete Installation", "Configured Infrastructure"],
    "correct": 1,
    "explanation": "Continuous Integration (CI) is the practice of frequently merging code changes into a shared repository, with automated builds and tests running on each merge to detect issues early."
  },
  {
    "id": "devasc-cicd-002",
    "question": "What is the primary goal of Continuous Delivery (CD)?",
    "options": ["To deploy every commit to production automatically", "To ensure code is always in a deployable state", "To eliminate the need for testing", "To replace manual code reviews"],
    "correct": 1,
    "explanation": "Continuous Delivery ensures that code is always in a deployable state by automating the build, test, and staging processes. Deployment to production may still require manual approval, unlike Continuous Deployment which is fully automated."
  },
  {
    "id": "devasc-cicd-003",
    "question": "Which file is commonly used to define a GitHub Actions CI/CD pipeline?",
    "options": ["Jenkinsfile", ".travis.yml", ".github/workflows/*.yml", "Dockerfile"],
    "correct": 2,
    "explanation": "GitHub Actions pipelines are defined in YAML files located in the .github/workflows/ directory. Jenkinsfile is for Jenkins, .travis.yml is for Travis CI."
  },
  {
    "id": "devasc-cicd-004",
    "question": "In a CI/CD pipeline, what typically happens first?",
    "options": ["Deploy to production", "Run integration tests", "Build the application", "Notify the team"],
    "correct": 2,
    "explanation": "A typical CI/CD pipeline starts with building/compiling the application, then runs unit tests, integration tests, and finally deploys. The build step verifies that the code compiles and dependencies resolve correctly."
  },
  {
    "id": "devasc-cicd-005",
    "question": "What is a 'pipeline artifact' in CI/CD?",
    "options": ["A bug found during testing", "A file or package produced by a build step that can be used in later stages", "A deprecated pipeline configuration", "A manual approval gate"],
    "correct": 1,
    "explanation": "An artifact is an output produced by a pipeline stage — such as a compiled binary, Docker image, or test report — that can be passed to subsequent stages or stored for deployment."
  },
  {
    "id": "devasc-cicd-006",
    "question": "What is the purpose of a 'staging environment' in a CI/CD workflow?",
    "options": ["To store source code", "To mirror production for final testing before release", "To run unit tests faster", "To manage Git branches"],
    "correct": 1,
    "explanation": "A staging environment closely mirrors production and is used for final validation (integration tests, UAT, performance tests) before deploying to production. It helps catch environment-specific issues."
  },
  {
    "id": "devasc-cicd-007",
    "question": "Which practice helps ensure that a CI pipeline catches bugs early?",
    "options": ["Running tests only before major releases", "Writing automated tests that run on every commit", "Deploying directly to production", "Using manual code review only"],
    "correct": 1,
    "explanation": "Automated tests running on every commit (or pull request) are the foundation of CI. They catch regressions and bugs as soon as they're introduced, when they're cheapest to fix."
  },
  {
    "id": "devasc-cicd-008",
    "question": "What is 'infrastructure as code' (IaC) in the context of CI/CD?",
    "options": ["Writing application code that manages infrastructure", "Defining infrastructure configuration in version-controlled files", "Using CI/CD to build physical servers", "Coding directly on production servers"],
    "correct": 1,
    "explanation": "Infrastructure as Code (IaC) means defining infrastructure (servers, networks, databases) in declarative configuration files (e.g., Terraform, CloudFormation) that are version-controlled and can be deployed through CI/CD pipelines."
  },
  {
    "id": "devasc-cicd-009",
    "question": "What is a 'webhook' in the context of CI/CD?",
    "options": ["A security vulnerability in pipelines", "An HTTP callback that triggers a pipeline when an event occurs", "A tool for monitoring production servers", "A Git branching strategy"],
    "correct": 1,
    "explanation": "A webhook is an HTTP callback triggered by an event (e.g., a git push or pull request). CI/CD platforms use webhooks to automatically start pipeline runs when code changes are pushed to a repository."
  },
  {
    "id": "devasc-cicd-010",
    "question": "What is the difference between Continuous Delivery and Continuous Deployment?",
    "options": ["They are the same thing", "Continuous Delivery requires manual approval to deploy; Continuous Deployment is fully automated", "Continuous Deployment only works with Docker", "Continuous Delivery skips testing"],
    "correct": 1,
    "explanation": "Continuous Delivery ensures code is always deployable but requires manual approval for production releases. Continuous Deployment goes further by automatically deploying every change that passes the pipeline to production."
  },
  {
    "id": "devasc-cicd-011",
    "question": "What is a blue/green deployment strategy?",
    "options": ["Deploying to two different cloud providers simultaneously", "Running two identical production environments and switching traffic from the old (blue) to the new (green) after verification", "Color-coding pipeline stages for visual clarity", "Deploying features only to internal users first"],
    "correct": 1,
    "explanation": "Blue/green deployment maintains two identical production environments. The current version runs on blue while the new version is deployed to green. After testing green, traffic is switched from blue to green. If issues arise, you can instantly switch back to blue, providing a fast rollback mechanism."
  },
  {
    "id": "devasc-cicd-012",
    "question": "How does a canary release differ from a blue/green deployment?",
    "options": ["Canary releases skip testing entirely", "Canary releases gradually roll out changes to a small subset of users before full deployment", "Canary releases only work with containerized applications", "Canary releases require two identical production environments running simultaneously"],
    "correct": 1,
    "explanation": "A canary release routes a small percentage of traffic (e.g., 5%) to the new version while most users stay on the current version. If metrics look good, traffic is gradually shifted. This reduces risk by limiting the blast radius of potential issues, unlike blue/green which switches all traffic at once."
  },
  {
    "id": "devasc-cicd-013",
    "question": "How should sensitive values like API keys and passwords be managed in CI/CD pipelines?",
    "options": ["Hardcode them directly in the pipeline configuration file", "Store them as encrypted secrets or environment variables in the CI/CD platform", "Commit them to the repository in a secrets.txt file", "Pass them as command-line arguments in the pipeline logs"],
    "correct": 1,
    "explanation": "CI/CD platforms provide encrypted secret storage (e.g., GitHub Secrets, GitLab CI Variables) that injects sensitive values as environment variables at runtime. Secrets should never be hardcoded in pipeline files or committed to repositories, as they would be visible in version history."
  },
  {
    "id": "devasc-cicd-014",
    "question": "What role does Docker play in CI/CD pipelines?",
    "options": ["Docker replaces the need for any CI/CD platform", "Docker provides consistent, reproducible build environments and packages applications into deployable containers", "Docker is only used for database management in pipelines", "Docker encrypts pipeline artifacts for secure storage"],
    "correct": 1,
    "explanation": "Docker ensures that builds and tests run in consistent, isolated environments regardless of the CI/CD runner's configuration. Applications are packaged into container images that run identically in development, staging, and production, eliminating 'works on my machine' issues."
  },
  {
    "id": "devasc-cicd-015",
    "question": "What is the difference between triggering a CI/CD pipeline 'on push' versus 'on pull request'?",
    "options": ["'On push' triggers when code is pushed to any branch; 'on pull request' triggers when a PR is opened or updated", "'On push' is for production; 'on pull request' is for staging only", "'On push' runs tests; 'on pull request' skips tests", "There is no difference — both trigger at the same time"],
    "correct": 0,
    "explanation": "'On push' triggers the pipeline whenever code is pushed to the configured branches. 'On pull request' triggers when a PR is created, updated, or synchronized. Teams often use 'on PR' for running tests and checks before merging, and 'on push to main' for deployment."
  },
  {
    "id": "devasc-cicd-016",
    "question": "Why do some CI/CD pipelines enforce minimum test coverage requirements?",
    "options": ["To make the pipeline run faster", "To ensure a baseline percentage of code is covered by automated tests, reducing the risk of undetected bugs", "To limit the number of tests that can be written", "To prevent developers from writing too much code"],
    "correct": 1,
    "explanation": "Test coverage thresholds (e.g., 80% minimum) ensure that new code is accompanied by tests. The pipeline fails if coverage drops below the threshold, encouraging developers to write tests and reducing the risk of deploying untested code paths. Coverage alone doesn't guarantee quality, but it helps prevent blind spots."
  },
  {
    "id": "devasc-cicd-017",
    "question": "In the context of CI/CD, what is a rollback and which deployment strategy makes rollbacks easiest?",
    "options": ["A rollback deletes the Git repository; trunk-based development makes it easiest", "A rollback reverts to the previous working version; blue/green deployments allow instant rollback by switching traffic back", "A rollback re-runs all pipeline stages; canary releases prevent the need for rollbacks entirely", "A rollback pauses the pipeline; manual deployments make rollbacks easiest"],
    "correct": 1,
    "explanation": "A rollback reverts the production environment to the previous stable version when a new deployment causes issues. Blue/green deployments make rollbacks nearly instant because the previous version is still running on the idle environment — you simply switch traffic back. Other strategies may require redeploying the old version."
  }
]
