[
  {
    "id": "devasc-git-001",
    "question": "Which Git command creates a new local repository in the current directory?",
    "options": ["git new", "git init", "git create", "git start"],
    "correct": 1,
    "explanation": "git init initializes a new Git repository in the current directory by creating a .git subdirectory with the necessary repository structure."
  },
  {
    "id": "devasc-git-002",
    "question": "What does 'git clone' do?",
    "options": ["Creates a new empty repository", "Copies a remote repository to your local machine", "Merges two branches together", "Pushes local changes to a remote"],
    "correct": 1,
    "explanation": "git clone creates a local copy of a remote repository, including all branches, commits, and history."
  },
  {
    "id": "devasc-git-003",
    "question": "Which command stages all modified and new files for the next commit?",
    "options": ["git commit -a", "git add .", "git stage --all", "git push"],
    "correct": 1,
    "explanation": "git add . stages all modified and untracked files in the current directory and subdirectories. git commit -a only stages modified tracked files, not new untracked files."
  },
  {
    "id": "devasc-git-004",
    "question": "What is the purpose of a .gitignore file?",
    "options": ["To list files that should be deleted from the repository", "To specify files and patterns that Git should not track", "To configure remote repository URLs", "To store Git credentials"],
    "correct": 1,
    "explanation": ".gitignore specifies intentionally untracked files that Git should ignore. Common entries include build artifacts, dependency directories (node_modules), and environment files (.env)."
  },
  {
    "id": "devasc-git-005",
    "question": "What does 'git merge feature-branch' do when run from the main branch?",
    "options": ["Deletes the feature branch", "Integrates changes from feature-branch into main", "Creates a new branch called feature-branch", "Pushes main to the feature branch"],
    "correct": 1,
    "explanation": "git merge integrates changes from the specified branch into the current branch. Running it from main merges feature-branch's commits into main."
  },
  {
    "id": "devasc-git-006",
    "question": "Which Git command shows the commit history of the current branch?",
    "options": ["git status", "git log", "git diff", "git show"],
    "correct": 1,
    "explanation": "git log displays the commit history for the current branch, showing commit hashes, authors, dates, and messages. git status shows working tree status, and git diff shows uncommitted changes."
  },
  {
    "id": "devasc-git-007",
    "question": "What is a Git 'pull request' (or 'merge request') used for?",
    "options": ["To download a repository for the first time", "To propose changes and request code review before merging", "To pull the latest changes from a remote", "To request access to a private repository"],
    "correct": 1,
    "explanation": "A pull request is a collaboration feature that lets you propose changes from one branch to another, enabling code review, discussion, and approval before merging."
  },
  {
    "id": "devasc-git-008",
    "question": "What happens during a Git merge conflict?",
    "options": ["Git automatically chooses the newer changes", "Git deletes the conflicting files", "Git marks the conflicting sections and requires manual resolution", "Git reverts both branches to their common ancestor"],
    "correct": 2,
    "explanation": "When Git cannot automatically merge changes (e.g., both branches modified the same lines), it marks the conflicting sections with conflict markers (<<<<, ====, >>>>) and requires manual resolution."
  },
  {
    "id": "devasc-git-009",
    "question": "What is the difference between 'git fetch' and 'git pull'?",
    "options": ["They are identical commands", "git fetch downloads changes without merging; git pull downloads and merges", "git fetch works with branches; git pull works with tags", "git pull is used for private repos; git fetch for public"],
    "correct": 1,
    "explanation": "git fetch downloads new data from a remote repository without integrating it into your working files. git pull is essentially git fetch followed by git merge — it downloads and immediately merges."
  },
  {
    "id": "devasc-git-010",
    "question": "Which branching strategy uses short-lived feature branches merged into a main branch?",
    "options": ["Trunk-based development", "GitHub Flow", "Gitflow", "All of the above"],
    "correct": 3,
    "explanation": "All three strategies use feature branches merged into a main branch, though they differ in complexity. GitHub Flow is the simplest (feature branches + main), Gitflow adds develop/release/hotfix branches, and trunk-based development emphasizes very short-lived branches."
  },
  {
    "id": "devasc-git-011",
    "question": "What is the main difference between git rebase and git merge?",
    "options": ["Rebase deletes the source branch; merge keeps it", "Rebase replays commits on top of another branch creating a linear history; merge creates a merge commit", "Rebase only works with remote branches; merge works with local branches", "Rebase is faster; merge is more accurate"],
    "correct": 1,
    "explanation": "git rebase moves or replays your branch's commits on top of another branch, creating a clean linear history. git merge combines branches by creating a new merge commit that has two parents. Rebase rewrites history, which is why it should not be used on shared/public branches."
  },
  {
    "id": "devasc-git-012",
    "question": "What does 'git stash' do?",
    "options": ["Permanently deletes uncommitted changes", "Temporarily saves uncommitted changes so you can switch branches with a clean working directory", "Creates a new branch from the current changes", "Pushes changes to a remote stash server"],
    "correct": 1,
    "explanation": "git stash temporarily shelves (stashes) your uncommitted changes, giving you a clean working directory. You can later restore them with git stash pop or git stash apply. This is useful when you need to switch branches but aren't ready to commit."
  },
  {
    "id": "devasc-git-013",
    "question": "What does 'git cherry-pick <commit-hash>' do?",
    "options": ["Deletes the specified commit from the branch", "Applies the changes from a specific commit onto the current branch", "Reverts all commits up to the specified one", "Marks a commit as important for future reference"],
    "correct": 1,
    "explanation": "git cherry-pick takes a single commit from another branch and applies its changes to the current branch as a new commit. This is useful when you need a specific fix from another branch without merging the entire branch."
  },
  {
    "id": "devasc-git-014",
    "question": "What is the purpose of git tags?",
    "options": ["To rename branches", "To mark specific commits as important reference points, typically for releases", "To add comments to files in the repository", "To create temporary branches for testing"],
    "correct": 1,
    "explanation": "Git tags mark specific points in history as important — most commonly used for release versions (e.g., v1.0.0, v2.1.3). Unlike branches, tags do not move as new commits are made. Annotated tags store extra metadata like tagger name, date, and message."
  },
  {
    "id": "devasc-git-015",
    "question": "What does HEAD point to in Git?",
    "options": ["The first commit in the repository", "The remote origin server", "The currently checked-out commit or branch", "The most recent tag"],
    "correct": 2,
    "explanation": "HEAD is a pointer to the current commit you are working on — usually it points to the tip of the currently checked-out branch. When you switch branches, HEAD moves to point to the new branch's latest commit."
  },
  {
    "id": "devasc-git-016",
    "question": "What is the difference between 'git reset --soft', '--mixed', and '--hard'?",
    "options": ["They affect different remote repositories", "--soft keeps changes staged, --mixed unstages changes but keeps them in working directory, --hard discards all changes", "--soft resets one commit, --mixed resets two, --hard resets all commits", "They are aliases for the same operation with different verbosity levels"],
    "correct": 1,
    "explanation": "git reset --soft moves HEAD but keeps changes staged. --mixed (the default) moves HEAD and unstages changes, but keeps them in your working directory. --hard moves HEAD and discards all changes entirely. Be cautious with --hard as it permanently deletes uncommitted work."
  },
  {
    "id": "devasc-git-017",
    "question": "What is a 'detached HEAD' state in Git, and when does it typically occur?",
    "options": ["It means the repository is corrupted and needs to be re-cloned", "HEAD points directly to a commit instead of a branch, typically after checking out a specific commit hash or tag", "It occurs when a merge conflict cannot be resolved", "It means the remote repository has been disconnected"],
    "correct": 1,
    "explanation": "Detached HEAD occurs when you check out a specific commit hash, tag, or remote branch directly — HEAD points to a commit instead of a branch name. Any new commits made in this state are not on any branch and can be lost if you switch away without creating a branch. Use 'git checkout -b new-branch' to save your work."
  }
]
